{% extends 'courses/base.html' %}
{% load static %}

{% block title %}Reprocess Content{% endblock %}

{% block content %}
<h1>{{ lesson.title }}</h1>

{% for task in lesson.task_set.all %}
<div>
    <h3>{{ task.name }}</h3>
    <h4>{{ task.description }}</h4>

        <textarea id="task-{{ task.id }}" placeholder="Output will appear here">{{ task.correct_code }}</textarea>
         <button onclick="handleExecutionClick('{{ task.id }}')">Send for execution</button>
    <script>
    const taskBlock{{ task.id }} = CodeMirror.fromTextArea(document.getElementById('task-' + {{ task.id }}), {
        lineNumbers: false,
        mode: 'python',
        theme: 'default',
        readOnly: true
    });

    const taskElement{{ task.id }} = taskBlock{{ task.id }}.getWrapperElement();
    taskElement{{ task.id }}.classList.add('customClass');
</script>
</div>
{% endfor %}

<div class="container">
    <div class="form-container">
        <div class="form-wrapper-left">
            <h2>Practice section:</h2>
            <form id="code-form">
                {% csrf_token %}
                <textarea name="code" id="code" placeholder="Your code here"></textarea>
                <p><button type="submit">Run Code</button></p>
            </form>
        </div>
        <div class="form-wrapper-right">
            <div id="preview"></div>
            <form id="code-form-ai" novalidate>
                <h2>AI CoPilot:</h2>
                {% csrf_token %}
                <textarea id="ai-output" name="ai-output" style="height: 80%;" placeholder="AI output will appear here"></textarea>
            </form>
            <form id="code-input-ai" novalidate>
                {% csrf_token %}
                <textarea id="ai-input" name="ai-output" style="height: 20%;" placeholder="AI output will appear here"></textarea>
                <p><button type="submit">Send Message</button></p>
            </form>
        </div>
    </div>
</div>

<div class="output-container">
    <h3>Compiler Output</h3>
    <textarea id="code_output" placeholder="Output will appear here"></textarea>
    <h3>Notebook</h3>
    <div id="root"></div>
</div>

<!-- Import React and any necessary libraries -->
<script src="https://unpkg.com/react@17/umd/react.development.js"></script>
<script src="https://unpkg.com/react-dom@17/umd/react-dom.development.js"></script>

<!-- Define React components -->

<!-- Mount React components -->
<script src="{% static 'js/react-app.js' %}"></script>
<!-- Mount React component to root element -->
<!-- Define your TextEditor component -->



    <script>



    let editor;
    let editor_AI;
    let input_AI;
    let output_form;
    let previousLine;
    let formData = new FormData();
    let AI_formData = new FormData();


    document.addEventListener('DOMContentLoaded', function () {
        const form = document.getElementById('code-form');
        const form_ai = document.getElementById('code-form-ai');
        const form_input_ai = document.getElementById('code-input-ai');
        AI_formData = new FormData(form_input_ai);
        output_form = CodeMirror.fromTextArea(document.getElementById('code_output'), {
            lineNumbers: false,
            mode: 'text',
            theme: 'tomorrow-night-eighties',
            readonly: true,

        });


        editor = CodeMirror.fromTextArea(form.querySelector('textarea'), {
            lineNumbers: true,
            mode: 'python',
            theme: 'tomorrow-night-eighties',
            gutters: ['CodeMirror-lint-markers'],
            lint: true,
            spellcheck:true
        });



         editor_AI = CodeMirror.fromTextArea(form_ai.querySelector('textarea'), {
              mode: "markdown",
              theme: "tomorrow-night-eighties",
              lineNumbers: false,
              lineWrapping: true

            });




            input_AI = CodeMirror.fromTextArea(form_input_ai.querySelector('textarea'), {
                    lineNumbers: false,
                    mode: 'text',
                    theme: 'tomorrow-night-eighties',
        });






        editor.setSize(null, "520px"); // Set the height to 400px
        editor_AI.setSize(null, "300px"); // Set the height to 400px
        input_AI.setSize(null, "200px"); // Set the height to 400px

        const editorElement = editor.getWrapperElement();
        const AI_editorElement = editor_AI.getWrapperElement();
        const AI_inputElement = input_AI.getWrapperElement();

        AI_editorElement.classList.add('customClass');
        editor_AI.setOption('readOnly', true);

        form_input_ai.addEventListener('submit', handleAIFormSubmission)
        // Define the event listener for form submission
        form.addEventListener('submit', handleFormSubmission);

        // Define the event listener for output_form content changes
        function handleOutputFormChange(instance, changeObj) {
            handleResponseAI(instance.getValue());
        }

        // Define the event listener for output_form content changes
        editor.on('change', function(instance, changeObj) {
            cleanHighlight(instance.getValue());
        });





        // Display the contents of the FormData object
        function logFormData(formData) {
            for (let pair of formData.entries()) {
                console.log(pair[0] + ': ' + pair[1]);
            }
        }



        // Function to clear all highlights from editor
        function cleanHighlight() {
        // Check if previousLine is not null before removing the class
            if (previousLine) {
                editor.removeLineClass(previousLine, 'background', 'highlighted-line');
                editor.removeLineClass(previousLine, 'background', 'error-highlighted-line');
                editor.removeLineClass(editor.lineCount()-1, 'background', 'highlighted-line-finish');
                previousLine = null;
            } else {
                editor.removeLineClass(editor.lineCount()-1, 'background', 'highlighted-line-finish');
            }
        }

    // Function to handle form submission to AI
    function handleResponseAI() {
    console.log('handleResponseAI triggered')
    const output = output_form.getValue().trim();
    const code = editor.getValue().trim();

    AI_formData.set('output', output);
    AI_formData.set('code', code);
    form_input_ai.dataset.code = code
    form_input_ai.dataset.output = output


    fetch('{% url 'process_code' %}', {
        method: 'POST',
        body: AI_formData,
        headers: {
            'X-CSRFToken': 'ZUP3t44Y65LUc73Xf9Ttev8TnyHF3QzKk4gmydjMKbletcifqGx3RUGNzQoH5WeK'
        }
    })
    .then(response => {

                editorElement.classList.remove('customClass');
                editor.setOption('readOnly', false);
        if (!response.ok) {
            throw new Error('Network response was not ok');
        }
        return response.json();
    })
    .then(data => {
        if (data.ai_response) {

            if (!editor_AI.getValue()) {

                AI_formData.append('thread_id', data.thread_id);
                AI_formData.append('assistant_id', data.assistant_id);

                // Call the function to log the contents of formData
                logFormData(AI_formData);
                // Set the content and mark specific lines as editable
                editor_AI.setValue("Coding Assistant (auto): " + data.ai_response);
            } else {
                // Call the function to log the contents of formData
                logFormData(AI_formData);
                // Set the content and mark specific lines as editable
                const thread = editor_AI.getValue()
                editor_AI.setValue(thread + '\n\nCoding Assistant (auto): ' + data.ai_response);
            }
        } else {
            if (!editor_AI.getValue()) {
            editor_AI.setValue('System: Assistant is not responding, please try in a moment.\nInput your question below again:\n');
        }

        }


    })
    .catch(error => {
        console.error('Error:', error);
        output_form.setValue('An error occurred while processing your request');
    });
}

                // Function to handle AI form submission
        function handleAIFormSubmission(event) {
            event.preventDefault();


            AI_inputElement.classList.add('customClass');
            input_AI.setOption('readOnly', true);

            message = input_AI.getValue();
            AI_formData.append('input_message', message);
            fetch('{% url 'chat_code' %}', {
                method: 'POST',
                body: AI_formData,
                headers: {
                    'X-CSRFToken': 'ZUP3t44Y65LUc73Xf9Ttev8TnyHF3QzKk4gmydjMKbletcifqGx3RUGNzQoH5WeK'
                }
            })
            .then(response => {
                AI_inputElement.classList.remove('customClass');
                input_AI.setOption('readOnly', false);
                if (!response.ok) {
                    throw new Error('Network response was not ok');
                }
                return response.json();
            })
            .then(data => {
                if (data.ai_response) {
                    console.log('thread id: ', data.thread_id);
                    // Append AI message to the thread
                    logFormData(AI_formData);
                    let thread = editor_AI.getValue();
                    editor_AI.setValue(thread + '\n\nUser: ' + message + '\n\nCoding Assistant: ' + data.ai_response);
                    // Delete message from input form
                    input_AI.setValue('');
                } else {
                    let thread = editor_AI.getValue();
                    editor_AI.setValue(thread + '\n\nUser: ' + message + '\n\nCoding Assistant: Assistant is not responding, try again in a moment...');
                }
            })
            .catch(error => {
                console.error('Error:', error);
                output_form.setValue('An error occurred while processing your request');
            });


        }



        // Function to handle form submission to server subprocess (interpreter)
        function handleFormSubmission(event) {
            event.preventDefault();

            formData = new FormData(form);

            let symbolsProcessed = 0;
            let inputsProcessed = 0
            const code = editor.getValue().trim();
            output_form.setValue('');
            // Check if code is empty
            if (code.trim() === '') {
                console.error('Code is empty');
                output_form.setValue('Please type your code before pressing "Submit" button.');
                editorElement.classList.remove('customClass');
                return;
            }
            // Add the event listener to capture output form changes
            output_form.on('change', handleOutputFormChange);

            // Initialize inputsProcessed to 0 if not already set
            form.dataset.inputsProcessed = form.dataset.inputsProcessed ? parseInt(form.dataset.inputsProcessed) : 0;
            // Initialize symbolsProcessed to '' if not already set
            form.dataset.symbolsProcessed = form.dataset.symbolsProcessed ? form.dataset.symbolsProcessed : '';
            formData.set('code', code);
            fetch('{% url 'process_lesson' lesson.id %}', {
                method: 'POST',
                body: formData,
                headers: {
                    'X-CSRFToken': 'ZUP3t44Y65LUc73Xf9Ttev8TnyHF3QzKk4gmydjMKbletcifqGx3RUGNzQoH5WeK'
                }
            })
            .then(response => {


                if (!response.ok) {
                    throw new Error('Network response was not ok');
                }
                return response.json();
            })
            .then(data => {
            AI_editorElement.classList.add('customClass');
            editorElement.classList.add('customClass');
            editor.setOption('readOnly', true);
            editor_AI.setOption('readOnly', true);
                if (data.input_requested) {
                    console.log('Control - move to Input!');
                    const prompt_line = parseInt(data.prompt_message);
                    output_form.setValue(data.output + '\n');

                    // Disable the event listener so we no longer track output form changes
                    output_form.off('change', handleOutputFormChange);
                    form.removeEventListener('submit', handleFormSubmission);

                    form.addEventListener('submit', handleInputSubmission);
                    //Update symbols processed stats
                    form.dataset.symbolsProcessed = data.output;


                    if (prompt_line) {
                        editor.addLineClass(prompt_line, 'background', 'highlighted-line');
                        previousLine = prompt_line;

                    }
                } else {
                const prompt_line = parseInt(data.prompt_message);
                    if (data.completed) {
                        console.log('Code Execution Finished Successfully on line',editor.lineCount());
                        output_form.setValue(data.output + '\nScript execution successfully completed on line ' + editor.lineCount());
                        editor.addLineClass(editor.lineCount()-1, 'background', 'highlighted-line-finish');
                        previousLine = editor.lineCount()-1;
                    } else {
                        console.log('Code Execution Failed on the line', prompt_line,'with message',data.message);
                        output_form.setValue(data.output + '\nCode Execution Failed with message' + data.message);
                        editor.addLineClass(prompt_line, 'background', 'error-highlighted-line');
                        previousLine = prompt_line;
                    }
                // Disable the event listener
                    output_form.off('change', handleOutputFormChange);

                formData.set('code', "");
                    fetch('{% url 'process_lesson' lesson.id %}', {
                    method: 'POST',
                    body: formData,
                    headers: {
                        'X-CSRFToken': 'ZUP3t44Y65LUc73Xf9Ttev8TnyHF3QzKk4gmydjMKbletcifqGx3RUGNzQoH5WeK'
                    }
                    });
                }
            });
        }







        // Function to handle input submission
        function handleInputSubmission(event) {
            event.preventDefault();

            // Get the value of the last line in the output form
            const outputLines = output_form.getValue().split('\n');
            const lastLine = outputLines[outputLines.length - 1];

            // Now you can use the content of the last line as user input
            const userInput = lastLine.trim();
            const userInputList = []

            // Add it to array
            userInputList.push(userInput);

            // Process the last line as needed
            console.log('userInputList', userInputList);

            // Proceed with further processing, such as sending the user input to the server
            formData.append('input_value', userInput);
            form.dataset.input_value = userInputList

            const currentInputsProcessed = parseInt(form.dataset.inputsProcessed) || 0;  // Parse as integer or default to 0 if NaN
            form.dataset.inputsProcessed = currentInputsProcessed + 1;
            formData.append('inputs_processed', form.dataset.inputsProcessed);
            formData.append('symbols_processed', form.dataset.symbolsProcessed);

            fetch('{% url 'process_lesson' lesson.id %}', {
                method: 'POST',
                body: formData,
                headers: {
                    'X-CSRFToken': 'ZUP3t44Y65LUc73Xf9Ttev8TnyHF3QzKk4gmydjMKbletcifqGx3RUGNzQoH5WeK'
                }
            })
            .then(response => {
                // Log the raw response content to the console
                console.log('Input response:', response);
                console.log('Content-Type:', response.headers.get('Content-Type'));
                editor.setOption('readOnly', true);
                editor_AI.setOption('readOnly', true);
                if (!response.ok) {
                    throw new Error('Network response was not ok');
                }
                return response.json();
            })
            .then(data => {

                if (data.input_requested) {
                    const prompt_line = parseInt(data.prompt_message);
                    const currentCode = output_form.getValue().trim();
                    const updatedCode = currentCode + '\n' + data.output + '\n';  // Append output on a new line
                    output_form.setValue(updatedCode);
                    //Update symbols processed stats
                    form.dataset.symbolsProcessed = form.dataset.symbolsProcessed + data.output;
                    console.log('Input requested at line: ', prompt_line);
                    if (previousLine) {
                        editor.removeLineClass(previousLine, 'background', 'highlighted-line');
                        editor.addLineClass(prompt_line, 'background', 'highlighted-line');
                        previousLine = prompt_line;
                        // Reset cursor position to the end of the last newly added line
                        //const cursorPos = { line: output_form.lineCount(), ch: output_form.getLine(output_form.lineCount()).length };
                        //output_form.setCursor(cursorPos);

                    }
                } else {                                    //no input requested
                    if (data.completed) {                   //execution completed
                    // Remove the event listener for input submission
                    form.removeEventListener('submit', handleInputSubmission);
                    // Add the event listener for form submission
                    form.addEventListener('submit', handleFormSubmission);
                    //Code execution complete, update output form with the code execution result
                        console.log('Code Execution Finished Successfully!');
                        const currentCode = output_form.getValue().trim();  // Get current code in output_form
                        const updatedCode = currentCode + '\n' + data.output + '\n' + 'Script Execution Completed. No error detected :)';  // Append output on a new line
                        output_form.setValue(updatedCode);
                        if (previousLine) {
                            console.log('Output_Form cleared_1');
                            editor.removeLineClass(previousLine, 'background', 'highlighted-line');
                            console.log('Output_Form cleared, line ', previousLine);
                            console.log(editor.lineCount());
                            editor.addLineClass(editor.lineCount(), 'background', 'highlighted-line-finish');
                            previousLine = null
                        } else {
                            console.log('Output_Form cleared_2');
                            console.log(editor.lineCount());
                            editor.addLineClass(editor.lineCount(), 'background', 'highlighted-line-finish');
                        }
                    } else {                                                // incomplete with error
                        console.log('Code Execution Stopped!');
                        const currentCode = output_form.getValue().trim();  // Get current code in output_form
                        const updatedCode = currentCode + '\n' + data.output + '\n' + 'Script Execution Completed. No error detected :)';  // Append output on a new line
                        output_form.setValue(updatedCode);
                        if (previousLine) {
                            console.log('Output_Form cleared_3');
                            editor.removeLineClass(previousLine, 'background', 'highlighted-line');
                            console.log('Output_Form cleared, line ', previousLine);
                            console.log(editor.lineCount());
                            editor.addLineClass(editor.lineCount(), 'background', 'error-highlighted-line');
                        } else {
                            console.log('Output_Form cleared_4');
                            console.log(editor.lineCount());
                            editor.addLineClass(editor.lineCount(), 'background', 'error-highlighted-line');
                        }
                    }
                    const AI_editorElement = editor_AI.getWrapperElement()
                    previousLine = null
                    editor.setOption('readOnly', false);

                    formData.set('code', "");
                    fetch('{% url 'process_lesson' lesson.id %}', {
                    method: 'POST',
                    body: formData,
                    headers: {
                        'X-CSRFToken': 'ZUP3t44Y65LUc73Xf9Ttev8TnyHF3QzKk4gmydjMKbletcifqGx3RUGNzQoH5WeK'
                    }
                    });
                    }
            })
            .catch(error => {
                console.error('Error:', error);
                output_form.setValue('An error occurred while processing your request');
            });
        }



    });

 function handleExecutionClick(taskId, event) {
        if (event) {
        event.preventDefault(); // Prevent form submission
        }
    const taskTextarea = document.getElementById('task-' + taskId);
    const code_example = taskTextarea.value
    editor.setValue(code_example);
    const taskData = new FormData();
    taskData.append('task_id', taskId);
    fetch('{% url 'chat_code' %}', {
                method: 'POST',
                body: taskData,
                headers: {
                    'X-CSRFToken': 'ZUP3t44Y65LUc73Xf9Ttev8TnyHF3QzKk4gmydjMKbletcifqGx3RUGNzQoH5WeK'
                }
            })
            .then(response => {
                Prism.highlightAll();
                if (!response.ok) {
                    throw new Error('Network response was not ok');
                }
                return response.json();
            })
            .then(data => {
            if (data.thread_id) {

                AI_formData = new FormData();
                AI_formData.append('thread_id', data.thread_id);
                AI_formData.append('assistant_id', data.assistant_id);
                AI_formData.append('code', code_example);
                AI_formData.append('output', '');
                // Assuming 'editor_AI' is another instance of CodeMirror
                editor_AI.setValue('###**Task:** ' + data.task_description +'\n\n##**Coding Assistant (auto):** Hello, my name is Mr.Code.\n\nI am your teaching assistant today! Nice to meet you and lets start our practice.\n\nI gave you some code examples to start practicing. ' + data.ai_response + '\n\nNow you can check the result of execution after pressing the Submit button. \n\nYou can ask me any questions you have about the lesson topic: {{ lesson.title }}'); // Replace 'lessonTitle' with the actual lesson title

                }

                });

 }




</script>

   <style>
    .highlighted-line {
        background-color: rgb(215, 212, 240); /* Set the background color to blue using RGB values */
        font-weight: bold; /* Set the text to bold */
    }
    .highlighted-line-finish {
        background-color: rgb(217, 217, 217); /* Set the background color to blue using RGB values */
        font-weight: bold; /* Set the text to bold */
    }
    .error-highlighted-line {
        background-color: rgb(236, 165, 158); /* Set the background color to blue using RGB values */
        font-weight: bold; /* Set the text to bold */
    }
</style>
<style>
.container {
    display: flex;
    justify-content: space-between;
    align-items: flex-start; /* Align items at the top */
}

.form-container {
    display: flex; /* Use flexbox to position forms side by side */
    width: 95%; /* Set the width of the form container */
    margin-bottom: 5%; /* Add margin to the top of the form wrapper */
}

.form-wrapper-left {
    width: 50%; /* Left form takes up 50% of the container width */
    margin-right: 1%; /* Add some space between forms */

}

.form-wrapper-right {
    display: flex;
    flex-direction: column;
    width: 50%; /* Right form takes up 50% of the container width */

}
.form-wrapper-right form {
    margin-bottom: 20px; /* Add margin between right side forms */
}

.output-container {
    width: 100%; /* Set the width of the output container */
}

#code_output {
    width: 100%; /* Ensure the output textarea takes up 100% width */
    height: 200px; /* Set the height of the output textarea to 200 pixels */
}

.customClass {
    background-color: rgb(247, 247, 247);

.CodeMirror {
    border: 1px solid #808080; /* Add a 1px solid border with color #ccc */
    border-radius: 5px; /* Add a border radius of 5px */
    padding: 5px; /* Add some padding inside the CodeMirror */
}
}

</style>

    <hr>
{% endblock %}



